#!/usr/bin/env -S deno run -A
// -*- mode: typescript; -*-
/** Commands for managing a local svn repository checkout. */
// vim: ft=typescript

import { parseArgs } from "node:util";
import * as process from "node:process";
import { mkdirSync, writeFileSync } from "node:fs";
import path from "node:path";

// Just for formatting timestamps in the current timezone offset, unfortunately
import { formatISO } from "npm:date-fns";
import { $, chalk } from "npm:zx";

// Force colors on even if we're piping to another program
// The main program we're piping to is `less -R`. We just want paging for the
// same output we'd get in the terminal normally.
chalk.level = 3;

import { link } from "npm:ansi-escapes";

import { fetchLogEntries, ArgLogMsgFormat, ArgLogSort } from "./utils.ts";

function showHelp() {
  console.log(`k-gitsvn [options]

Commands for managing a local checkout of an svn repository with git.

The Git repository is only here locally, and is used for local diff checking.

Subcommands and options:
  --setup: make sure .svn is ignored
  --check: do an msgfmt check for all po files
  --update: svn update; git add .; git commit
  --msg: copy latest Git commit message into the clipboard.
    Assumes xclip is installed and working.
  --log: Like \`svn log\` but exclude revisions from scripty.
    This subcommand has its own options:
    --limit, -l <n>: the --limit argument of svn log.
    --since <date>: Provide log from <date> to HEAD.
    --exclude <comma separated names>: Exclude a different set of authors
    --unhighlighted <comma separated names>: Highlight everyone except these
    --msgFormat none|full|one-line: how to show messages. Defaults to full messages.
    --sort none|new-first|old-first: how to sort messages. Defaults to new to old.
    Example:
      Fetch the last 100 revisions then exclude scripty changes:
        k-gitsvn --log -l 100
      Fetch revisions since 2025-01-01 then exclude scripty changes:
        k-gitsvn --log --since "2025-01-01"
      Fetch the last 100 revisions excluding authors "a" and "b":
        k-gitsvn --log --exclude "a,b" # scripty is included in this case
  --help, -h: Show help (this message)`);
}

/** Ensure the repository is as expected. */
async function cmdSetup() {
  const toplevel = (await $`git rev-parse --show-toplevel`.text()).trim();
  const dotSvnNotExcluded = (
    await $`cd ${toplevel}; git status -s`.text()
  ).includes(".svn");
  if (dotSvnNotExcluded) {
    console.log(".svn doesn't seem excluded. Excluding locally.");
    mkdirSync(path.join(toplevel, ".git", "info"), { recursive: true });
    writeFileSync(path.join(toplevel, ".git", "info", "exclude"), `.svn/`);
  }
}

/**
 * Pull from svn and do a Git commit for the latest state.
 * Assumes the repository is already set up, namely that .svn is already
 * excluded by Git.
 */
async function cmdUpdate() {
  await $({
    verbose: true,
    nothrow: true,
  })`svn update; git add .; git commit -m before`;
}

/**
 * Show and copy message of the latest commit from Git.
 * The plumbing from this to svn commit is not yet done. For now just, uh, run
 * the command yourself and paste it in.
 */
async function cmdMsg() {
  const message = (
    await $`git show --format="%B" --no-patch HEAD`.text()
  ).trim();
  console.log(message);
  // -l <n> specifies how many X requests before it exits. This is a quirk
  // with how the clipboard in X is by default a communication channel between
  // apps (copy source needs to be active to paste).
  // -l 1 should allow eg. the KDE clipboard to take ownership of it and then
  // for xclip to exit, but that for some reason doesn't work. -l 2 works. :shrug:
  // This is my own script, it doesn't have to be super reliable.
  await $({
    input: message + "\n",
  })`xclip -silent -r -l 2 -selection clipboard`;
}

async function cmdCheck() {
  await $({
    verbose: true,
    nothrow: true,
  })`fd '\.po$' -x msgfmt -o /dev/null --check-format`;
}

async function cmdLog(opts?: {
  /** --limit as passed to svn log. Defaults to 100 if --since is not
   * provided, undefined if it is. */
  limit?: string;
  /** List changes from this date to HEAD. */
  since?: string;
  /** Exclude these authors. Comma-separated. Defaults to "scripty". */
  exclude?: string;
  /** Highlight all authors except these. Comma-separated. Defaults to "moonlight". */
  unhighlighted?: string;
  /** How to sort log entries. Undefined means return whatever svn log returns. */
  sort?: string;
  /** How to show commit messages. */
  msgFormat?: string;
}) {
  console.error("Fetching log messages from remote...");
  const revision = opts?.since && `{${opts.since}}:HEAD`;
  // When --since is provided, --limit should act like no limit by default
  // but when --since is not provided, --limit should have a default of 100
  const limit = opts?.limit ?? (revision ? undefined : "100");
  // Specify defaults in one place.
  const sort = ArgLogSort.parse(opts?.sort ?? "new-first");
  const msgFormat = ArgLogMsgFormat.parse(opts?.msgFormat ?? "full");
  const logentries = await fetchLogEntries({
    limit,
    revision,
    sort,
  });
  const sep = "-".repeat(72);
  const excludeSet = new Set(
    // We have to use an explicit check against undefined, because the
    // empty string is falsy.
    // We want an empty string to take the latter case and result in an empty
    // excludes list instead of using the fallback.
    opts?.exclude === undefined ? ["scripty"] : opts?.exclude.split(",")
  );
  const unhighlightedSet = new Set(
    opts?.unhighlighted === undefined
      ? ["moonlight"]
      : opts?.unhighlighted.split(",")
  );
  const authors = new Map<string, number>();

  console.log(`--limit: ${limit ?? "unspecified"}
--revision: ${revision ?? "unspecified"}
Sort: ${sort ?? "unspecified"}
Excluded authors: ${[...excludeSet].join(", ")}
Unhighlighted authors: ${[...unhighlightedSet].join(", ")}
`);

  for (const entry of logentries) {
    authors.set(entry.author, (authors.get(entry.author) || 0) + 1);
    if (excludeSet.has(entry.author)) continue;
    const moment = entry.date;
    console.log(sep);
    const revision = entry["@_revision"];
    console.log(
      `r${link(
        revision,
        `https://websvn.kde.org/?view=revision&revision=${revision}`
      )} | ${
        unhighlightedSet.has(entry.author)
          ? entry.author
          : chalk.yellow(entry.author)
      } | ${formatISO(moment)}`
    );
    if (msgFormat === "full") {
      console.log(entry.msg);
    } else if (msgFormat === "one-line") {
      const newlinePos = entry.msg.indexOf("\n");
      if (newlinePos === -1) {
        console.log(entry.msg);
      } else {
        console.log(entry.msg.substring(0, newlinePos));
      }
    }
  }
  console.log(sep);
  console.log(`
Stats:`);
  console.log(
    Object.fromEntries([...authors].sort((a, b) => (a[1] < b[1] ? 1 : -1)))
  );
}

async function main() {
  const parsedArgs = parseArgs({
    allowPositionals: true,
    options: {
      help: { type: "boolean", short: "h" },
      update: { type: "boolean" },
      setup: { type: "boolean" },
      check: { type: "boolean" },
      msg: { type: "boolean" },

      log: { type: "boolean" },
      limit: { type: "string", short: "l" },
      since: { type: "string" },
      sort: { type: "string" },
      exclude: { type: "string" },
      unhighlighted: { type: "string" },
      msgFormat: { type: "string" },
    },
  });
  if (parsedArgs.values.help) {
    showHelp();
    process.exit(0);
  }
  if (parsedArgs.values.update) {
    await cmdUpdate();
  } else if (parsedArgs.values.check) {
    await cmdCheck();
  } else if (parsedArgs.values.setup) {
    await cmdSetup();
  } else if (parsedArgs.values.msg) {
    await cmdMsg();
  } else if (parsedArgs.values.log) {
    await cmdLog({
      limit: parsedArgs.values.limit,
      since: parsedArgs.values.since,
      sort: parsedArgs.values.sort,
      exclude: parsedArgs.values.exclude,
      unhighlighted: parsedArgs.values.unhighlighted,
      msgFormat: parsedArgs.values.msgFormat,
    });
  }
}

// Ignore top level errors
// If we pipe output to less then quit it without viewing the whole
// thing, the pager doesn't consume the entire pipe, which leads to a
// BrokenPipe error.
// This is the overkill but fast way to get rid of it.
main().catch(() => {});
