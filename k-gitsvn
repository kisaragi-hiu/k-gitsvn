#!/usr/bin/env -S deno run -A
// -*- mode: typescript; lsp-enabled-clients: (deno-ls); -*-
/** Commands for managing a local svn repository checkout. */
// vim: ft=typescript

import { parseArgs } from "node:util";
import * as process from "node:process";
import { mkdirSync, writeFileSync } from "node:fs";
import path from "node:path";

// Just for formatting timestamps in the current timezone offset, unfortunately
import { formatISO } from "npm:date-fns";
import { $ } from "npm:zx";
import { XMLParser } from "npm:fast-xml-parser";
import * as z from "npm:zod";

function showHelp() {
  console.log(`k-gitsvn [options]

Commands for managing a local checkout of an svn repository with git.

The Git repository is only here locally, and is used for local diff checking.

Subcommands and options:
  --setup: make sure .svn is ignored
  --check: do an msgfmt check for all po files
  --update: svn update; git add .; git commit
  --msg: copy latest Git commit message into the clipboard.
    Assumes xclip is installed and working.
  --log <arg>: show recent revision messages, excluding ones from scripty
    <arg> is passed to svn log as the --limit argument.
    Example:
    Fetch the last 100 revisions then exclude scripty changes:
      k-gitsvn --log 100
  --help, -h: Show help (this message)`);
}

/** Ensure the repository is as expected. */
async function cmdSetup() {
  const toplevel = (await $`git rev-parse --show-toplevel`.text()).trim();
  const dotSvnNotExcluded = (
    await $`cd ${toplevel}; git status -s`.text()
  ).includes(".svn");
  if (dotSvnNotExcluded) {
    console.log(".svn doesn't seem excluded. Excluding locally.");
    mkdirSync(path.join(toplevel, ".git", "info"), { recursive: true });
    writeFileSync(path.join(toplevel, ".git", "info", "exclude"), `.svn/`);
  }
}

/**
 * Pull from svn and do a Git commit for the latest state.
 * Assumes the repository is already set up, namely that .svn is already
 * excluded by Git.
 */
async function cmdUpdate() {
  await $({
    verbose: true,
    nothrow: true,
  })`svn update; git add .; git commit -m before`;
}

/**
 * Show and copy message of the latest commit from Git.
 * The plumbing from this to svn commit is not yet done. For now just, uh, run
 * the command yourself and paste it in.
 */
async function cmdMsg() {
  const message = (
    await $`git show --format="%B" --no-patch HEAD`.text()
  ).trim();
  console.log(message);
  // -l <n> specifies how many X requests before it exits. This is a quirk
  // with how the clipboard in X is by default a communication channel between
  // apps (copy source needs to be active to paste).
  // -l 1 should allow eg. the KDE clipboard to take ownership of it and then
  // for xclip to exit, but that for some reason doesn't work. -l 2 works. :shrug:
  // This is my own script, it doesn't have to be super reliable.
  await $({
    input: message + "\n",
  })`xclip -silent -r -l 2 -selection clipboard`;
}

async function cmdCheck() {
  await $({
    verbose: true,
    nothrow: true,
  })`fd '\.po$' -x msgfmt -o /dev/null --check-format`;
}

async function cmdLog(limit: string) {
  function ensureArray<T>(val: T) {
    return Array.isArray(val) ? val : [val];
  }
  const SvnLogRaw = z.object({
    log: z.object({
      logentry: z.preprocess(
        ensureArray,
        z.array(
          z.object({
            ["@_revision"]: z.string(),
            author: z.string(),
            date: z.string(),
            msg: z.string(),
          })
        )
      ),
    }),
  });
  const output = await $`svn log --xml --limit ${limit}`.text();
  const parser = new XMLParser({ ignoreAttributes: false });
  const raw = parser.parse(output);
  const logentries = SvnLogRaw.parse(raw).log.logentry;
  const sep = "-".repeat(72);
  for (const entry of logentries) {
    if (entry.author === "scripty") continue;
    const moment = Date.parse(entry.date);
    console.log(sep);
    console.log(
      `r${entry["@_revision"]} | ${entry.author} | ${formatISO(moment)}`
    );
    console.log(entry.msg);
  }
  console.log(sep);
}

async function main() {
  const parsedArgs = parseArgs({
    allowPositionals: true,
    options: {
      help: { type: "boolean", short: "h" },
      update: { type: "boolean" },
      setup: { type: "boolean" },
      check: { type: "boolean" },
      msg: { type: "boolean" },
      log: { type: "string" },
    },
  });
  if (parsedArgs.values.help) {
    showHelp();
    process.exit(0);
  }
  if (parsedArgs.values.update) {
    await cmdUpdate();
  } else if (parsedArgs.values.check) {
    await cmdCheck();
  } else if (parsedArgs.values.setup) {
    await cmdSetup();
  } else if (parsedArgs.values.msg) {
    await cmdMsg();
  } else if (parsedArgs.values.log) {
    await cmdLog(parsedArgs.values.log);
  }
}

main();
